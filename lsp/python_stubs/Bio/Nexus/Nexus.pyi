from . import cnexus as cnexus
from Bio import BiopythonWarning as BiopythonWarning, File as File
from Bio.Data import IUPACData as IUPACData
from Bio.Nexus.StandardData import StandardData as StandardData
from Bio.Nexus.Trees import Tree as Tree
from Bio.Seq import Seq as Seq
from _typeshed import Incomplete

INTERLEAVE: int
SPECIAL_COMMANDS: Incomplete
KNOWN_NEXUS_BLOCKS: Incomplete
PUNCTUATION: str
MRBAYESSAFE: str
WHITESPACE: str
SPECIALCOMMENTS: Incomplete
CHARSET: str
TAXSET: str
CODONPOSITIONS: str
DEFAULTNEXUS: str

class NexusError(Exception): ...

class CharBuffer:
    buffer: Incomplete
    def __init__(self, string) -> None: ...
    def peek(self): ...
    def peek_nonwhitespace(self): ...
    def __next__(self): ...
    def next_nonwhitespace(self): ...
    def skip_whitespace(self) -> None: ...
    def next_until(self, target): ...
    def peek_word(self, word): ...
    def next_word(self): ...
    def rest(self): ...

class StepMatrix:
    data: Incomplete
    symbols: Incomplete
    def __init__(self, symbols, gap) -> None: ...
    def set(self, x, y, value) -> None: ...
    def add(self, x, y, value) -> None: ...
    def sum(self): ...
    def transformation(self): ...
    def weighting(self): ...
    def smprint(self, name: str = 'your_name_here'): ...

def safename(name, mrbayes: bool = False): ...
def quotestrip(word): ...
def get_start_end(sequence, skiplist=('-', '?')): ...
def combine(matrices): ...

class Commandline:
    options: Incomplete
    command: Incomplete
    def __init__(self, line, title) -> None: ...

class Block:
    title: Incomplete
    commandlines: Incomplete
    def __init__(self, title: Incomplete | None = None) -> None: ...

class Nexus:
    ntax: int
    nchar: int
    unaltered_taxlabels: Incomplete
    taxlabels: Incomplete
    charlabels: Incomplete
    statelabels: Incomplete
    datatype: str
    respectcase: bool
    missing: str
    gap: str
    symbols: Incomplete
    equate: Incomplete
    matchchar: Incomplete
    labels: Incomplete
    transpose: bool
    interleave: bool
    tokens: bool
    eliminate: Incomplete
    matrix: Incomplete
    unknown_blocks: Incomplete
    taxsets: Incomplete
    charsets: Incomplete
    charpartitions: Incomplete
    taxpartitions: Incomplete
    trees: Incomplete
    translate: Incomplete
    structured: Incomplete
    set: Incomplete
    options: Incomplete
    codonposset: Incomplete
    def __init__(self, input: Incomplete | None = None) -> None: ...
    filename: Incomplete
    def read(self, input) -> None: ...
    def write_nexus_data_partitions(self, matrix: Incomplete | None = None, filename: Incomplete | None = None, blocksize: Incomplete | None = None, interleave: bool = False, exclude=(), delete=(), charpartition: Incomplete | None = None, comment: str = '', mrbayes: bool = False): ...
    def write_nexus_data(self, filename: Incomplete | None = None, matrix: Incomplete | None = None, exclude=(), delete=(), blocksize: Incomplete | None = None, interleave: bool = False, interleave_by_partition: bool = False, comment: Incomplete | None = None, omit_NEXUS: bool = False, append_sets: bool = True, mrbayes: bool = False, codons_block: bool = True): ...
    def append_sets(self, exclude=(), delete=(), mrbayes: bool = False, include_codons: bool = True, codons_only: bool = False): ...
    def export_fasta(self, filename: Incomplete | None = None, width: int = 70): ...
    def export_phylip(self, filename: Incomplete | None = None): ...
    def constant(self, matrix: Incomplete | None = None, delete=(), exclude=()): ...
    def cstatus(self, site, delete=(), narrow: bool = True): ...
    def weighted_stepmatrix(self, name: str = 'your_name_here', exclude=(), delete=()): ...
    def crop_matrix(self, matrix: Incomplete | None = None, delete=(), exclude=()): ...
    def bootstrap(self, matrix: Incomplete | None = None, delete=(), exclude=()): ...
    def add_sequence(self, name, sequence) -> None: ...
    def insert_gap(self, pos, n: int = 1, leftgreedy: bool = False): ...
    def invert(self, charlist): ...
    def gaponly(self, include_missing: bool = False): ...
    def terminal_gap_to_missing(self, missing: Incomplete | None = None, skip_n: bool = True) -> None: ...
