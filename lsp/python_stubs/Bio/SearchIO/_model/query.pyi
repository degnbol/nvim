from ._base import _BaseSearchObject
from .hit import Hit as Hit
from Bio.SearchIO._utils import optionalcascade as optionalcascade
from _typeshed import Incomplete
from collections.abc import Generator

class QueryResult(_BaseSearchObject):
    program: str
    target: str
    version: str
    def __init__(self, hits=(), id: Incomplete | None = None, hit_key_function: Incomplete | None = None) -> None: ...
    def __iter__(self): ...
    @property
    def hits(self): ...
    @property
    def hit_keys(self): ...
    @property
    def items(self): ...
    def iterhits(self) -> Generator[Incomplete, Incomplete]: ...
    def iterhit_keys(self) -> Generator[Incomplete, Incomplete]: ...
    def iteritems(self) -> Generator[Incomplete, Incomplete]: ...
    def __contains__(self, hit_key) -> bool: ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __getitem__(self, hit_key): ...
    id: Incomplete
    description: Incomplete
    def __setitem__(self, hit_key, hit) -> None: ...
    def __delitem__(self, hit_key) -> None: ...
    @property
    def hsps(self): ...
    @property
    def fragments(self): ...
    def absorb(self, hit) -> None: ...
    def append(self, hit) -> None: ...
    def hit_filter(self, func: Incomplete | None = None): ...
    def hit_map(self, func: Incomplete | None = None): ...
    def hsp_filter(self, func: Incomplete | None = None): ...
    def hsp_map(self, func: Incomplete | None = None): ...
    def pop(self, hit_key: int = -1, default=...): ...
    def index(self, hit_key): ...
    def sort(self, key: Incomplete | None = None, reverse: bool = False, in_place: bool = True): ...
