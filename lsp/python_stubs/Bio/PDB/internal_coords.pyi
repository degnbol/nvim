import numpy as np
from Bio.Data.PDBData import protein_letters_3to1 as protein_letters_3to1
from Bio.PDB.Atom import Atom as Atom, DisorderedAtom as DisorderedAtom
from Bio.PDB.Residue import Residue as Residue
from Bio.PDB.ic_data import dihedra_primary_defaults as dihedra_primary_defaults, hedra_defaults as hedra_defaults, ic_data_backbone as ic_data_backbone, ic_data_sidechain_extras as ic_data_sidechain_extras, ic_data_sidechains as ic_data_sidechains, primary_angles as primary_angles, residue_atom_bond_state as residue_atom_bond_state
from Bio.PDB.vectors import coord_space as coord_space, multi_coord_space as multi_coord_space, multi_rot_Z as multi_rot_Z
from _typeshed import Incomplete
from typing import NamedTuple

HKT: Incomplete
DKT: Incomplete
EKT = HKT | DKT
BKT: Incomplete
HACS: Incomplete
DACS: Incomplete

class IC_Chain:
    MaxPeptideBond: float
    ParallelAssembleResidues: bool
    AAsiz: int
    atomArray: np.array
    dCoordSpace: Incomplete
    dcsValid: Incomplete
    chain: Incomplete
    ordered_aa_ic_list: list[IC_Residue]
    initNCaCs: Incomplete
    sqMaxPeptideBond: Incomplete
    hedra: Incomplete
    dihedra: Incomplete
    atomArrayIndex: dict[AtomKey, int]
    bpAtomArray: list[Atom]
    def __init__(self, parent, verbose: bool = False) -> None: ...
    def __deepcopy__(self, memo) -> IC_Chain: ...
    def clear_ic(self) -> None: ...
    aktuple: Incomplete
    atomArrayValid: Incomplete
    def build_atomArray(self) -> None: ...
    hAtoms: np.ndarray
    hAtomsR: np.ndarray
    hAtoms_needs_update: Incomplete
    a2h_map: Incomplete
    a2ha_map: Incomplete
    h2aa: Incomplete
    dAtoms: np.ndarray
    a4_pre_rotation: Incomplete
    dRev: np.ndarray
    dH1ndx: Incomplete
    dH2ndx: Incomplete
    h1d_map: Incomplete
    id3_dh_index: Incomplete
    id32_dh_index: Incomplete
    a2da_map: Incomplete
    d2a_map: Incomplete
    dFwd: Incomplete
    a2d_map: Incomplete
    dAtoms_needs_update: Incomplete
    def build_edraArrays(self) -> None: ...
    dSet: Incomplete
    dSetValid: Incomplete
    def assemble_residues(self, verbose: bool = False) -> None: ...
    def assemble_residues_ser(self, verbose: bool = False, start: int | None = None, fin: int | None = None) -> None: ...
    hedraLen: Incomplete
    hedraL12: Incomplete
    hedraAngle: Incomplete
    hedraL23: Incomplete
    hedraNdx: Incomplete
    dihedraLen: Incomplete
    dihedraAngle: Incomplete
    dihedraAngleRads: Incomplete
    dihedraNdx: Incomplete
    def init_edra(self, verbose: bool = False) -> None: ...
    def init_atom_coords(self) -> None: ...
    def update_dCoordSpace(self, workSelector: np.ndarray | None = None) -> None: ...
    def propagate_changes(self) -> None: ...
    def internal_to_atom_coordinates(self, verbose: bool = False, start: int | None = None, fin: int | None = None) -> None: ...
    def atom_to_internal_coordinates(self, verbose: bool = False) -> None: ...
    def distance_plot(self, filter: np.ndarray | None | None = None) -> np.ndarray: ...
    def dihedral_signs(self) -> np.ndarray: ...
    hedraL13: Incomplete
    dihedraL14: Incomplete
    dihedra_signs: Incomplete
    def distplot_to_dh_arrays(self, distplot: np.ndarray, dihedra_signs: np.ndarray) -> None: ...
    def distance_to_internal_coordinates(self, resetAtoms: bool | None | None = True) -> None: ...
    def copy_initNCaCs(self, other: IC_Chain) -> None: ...
    def make_extended(self) -> None: ...

class IC_Residue:
    accept_resnames: Incomplete
    no_altloc: bool
    gly_Cbeta: bool
    pic_accuracy: str
    accept_backbone: Incomplete
    accept_sidechain: Incomplete
    accept_mainchain: Incomplete
    accept_hydrogens: Incomplete
    accept_deuteriums: Incomplete
    accept_atoms: Incomplete
    residue: Incomplete
    cic: IC_Chain
    hedra: dict[HKT, Hedron]
    dihedra: dict[DKT, Dihedron]
    akc: dict[str | Atom, AtomKey]
    ak_set: set[AtomKey]
    rprev: list[IC_Residue]
    rnext: list[IC_Residue]
    bfactors: dict[str, float]
    alt_ids: list[str] | None
    is20AA: bool
    isAccept: bool
    rbase: Incomplete
    lc: Incomplete
    def __init__(self, parent: Residue) -> None: ...
    def __deepcopy__(self, memo): ...
    def __contains__(self, ak: AtomKey) -> bool: ...
    def rak(self, atm: str | Atom) -> AtomKey: ...
    def pretty_str(self) -> str: ...
    def set_flexible(self) -> None: ...
    def set_hbond(self) -> None: ...
    def clear_transforms(self) -> None: ...
    def assemble(self, resetLocation: bool = False, verbose: bool = False) -> dict['AtomKey', np.array] | dict[HKT, np.array] | None: ...
    def split_akl(self, lst: tuple['AtomKey', ...] | list['AtomKey'], missingOK: bool = False) -> list[tuple['AtomKey', ...]]: ...
    atom_sernum: Incomplete
    atom_chain: Incomplete
    def pdb_residue_string(self) -> str: ...

    class _pfDef(NamedTuple):
        psi: Incomplete
        omg: Incomplete
        phi: Incomplete
        tau: Incomplete
        chi1: Incomplete
        chi2: Incomplete
        chi3: Incomplete
        chi4: Incomplete
        chi5: Incomplete
        pomg: Incomplete
        chi: Incomplete
        classic_b: Incomplete
        classic: Incomplete
        hedra: Incomplete
        primary: Incomplete
        secondary: Incomplete
        all: Incomplete
        initAtoms: Incomplete
        bFactors: Incomplete
    pic_flags: Incomplete
    picFlagsDefault: Incomplete
    picFlagsDict: Incomplete
    def pick_angle(self, angle_key: EKT | str) -> Hedron | Dihedron | None: ...
    def get_angle(self, angle_key: EKT | str) -> float | None: ...
    def set_angle(self, angle_key: EKT | str, v: float, overlap: bool = True): ...
    def bond_rotate(self, angle_key: EKT | str, delta: float): ...
    def bond_set(self, angle_key: EKT | str, val: float): ...
    def pick_length(self, ak_spec: str | BKT) -> tuple[list['Hedron'] | None, BKT | None]: ...
    def get_length(self, ak_spec: str | BKT) -> float | None: ...
    def set_length(self, ak_spec: str | BKT, val: float) -> None: ...
    def applyMtx(self, mtx: np.array) -> None: ...

class Edron:
    edron_re: Incomplete
    @staticmethod
    def gen_key(lst: list['AtomKey']) -> str: ...
    @staticmethod
    def gen_tuple(akstr: str) -> tuple: ...
    atomkeys: Incomplete
    id: Incomplete
    needs_update: bool
    cic: IC_Chain
    e_class: str
    re_class: str
    cre_class: str
    rc: Incomplete
    def __init__(self, *args: list['AtomKey'] | EKT, **kwargs: str) -> None: ...
    def __deepcopy__(self, memo): ...
    def __contains__(self, ak: AtomKey) -> bool: ...
    def is_backbone(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...

class Hedron(Edron):
    xrh_class: Incomplete
    def __init__(self, *args: list['AtomKey'] | HKT, **kwargs: str) -> None: ...
    @property
    def angle(self) -> float: ...
    @angle.setter
    def angle(self, angle_deg) -> None: ...
    @property
    def len12(self): ...
    @len12.setter
    def len12(self, len) -> None: ...
    @property
    def len23(self) -> float: ...
    @len23.setter
    def len23(self, len) -> None: ...
    def get_length(self, ak_tpl: BKT) -> float | None: ...
    def set_length(self, ak_tpl: BKT, newLength: float): ...

class Dihedron(Edron):
    hedron1: Hedron
    hedron2: Hedron
    h1key: HKT
    h2key: HKT
    id3: HKT
    id32: HKT
    ric: IC_Residue
    reverse: bool
    def __init__(self, *args: list['AtomKey'] | DKT, **kwargs: str) -> None: ...
    @property
    def angle(self) -> float: ...
    needs_update: bool
    @angle.setter
    def angle(self, dangle_deg_in: float) -> None: ...
    @staticmethod
    def angle_dif(a1: float | np.ndarray, a2: float | np.ndarray): ...
    @staticmethod
    def angle_avg(alst: list, in_rads: bool = False, out_rads: bool = False): ...
    @staticmethod
    def angle_pop_sd(alst: list, avg: float): ...
    def difference(self, other: Dihedron) -> float: ...
    def bits(self) -> int: ...

class AtomKey:
    atom_re: Incomplete
    fieldNames: Incomplete

    class _fieldsDef(NamedTuple):
        respos: Incomplete
        icode: Incomplete
        resname: Incomplete
        atm: Incomplete
        altloc: Incomplete
        occ: Incomplete
    fields: Incomplete
    d2h: bool
    ric: Incomplete
    id: Incomplete
    akl: Incomplete
    missing: bool
    def __init__(self, *args: IC_Residue | Atom | list | dict | str, **kwargs: str) -> None: ...
    def __deepcopy__(self, memo): ...
    def __hash__(self) -> int: ...
    def altloc_match(self, other: AtomKey) -> bool: ...
    def is_backbone(self) -> bool: ...
    def atm(self) -> str: ...
    def cr_class(self) -> str | None: ...
    def __ne__(self, other: object) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...

def set_accuracy_95(num: float) -> float: ...

class HedronMatchError(Exception): ...
class MissingAtomError(Exception): ...
